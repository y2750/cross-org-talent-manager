# 跨组织人才管理系统 - 阶段工作汇报

## 📋 目录

1. [项目概述](#项目概述)
2. [已完成功能](#已完成功能)
3. [技术亮点与技术难点](#技术亮点与技术难点)
4. [将来实现的功能](#将来实现的功能)
5. [总结与展望](#总结与展望)

---

## 一、项目概述

### 1.1 项目背景

跨组织人才管理系统旨在解决中小微企业招聘中面临的背调难、成本高、不深入的问题，帮助企业规避雇佣风险。系统通过建立员工职业数字档案，记录员工在各企业的工作表现，为新雇主提供客观、全面、真实的员工能力评估依据。

### 1.2 技术架构

- **后端框架**：Spring Boot 3.x + MyBatis-Flex
- **前端框架**：Vue 3 + TypeScript + Ant Design Vue
- **数据库**：MySQL 8.0
- **对象存储**：腾讯云 COS
- **开发工具**：Maven、Git

---

## 二、已完成功能

### 2.1 用户管理系统 ✅

- **用户注册与登录**：支持多角色注册（管理员、HR、公司管理员、员工）
- **身份认证**：基于 JWT Token 的认证机制
- **权限管理**：基于 AOP 的权限拦截器，支持角色等级控制
- **用户信息管理**：用户基本信息维护、密码修改

### 2.2 企业管理模块 ✅

- **企业注册与认证**：企业信息录入、行业分类管理
- **企业信息维护**：企业基本信息、联系方式、行业信息管理
- **企业积分表结构**：已创建积分变动记录表，为后续积分系统奠定基础

### 2.3 部门管理模块 ✅

- **部门创建与管理**：支持多层级部门管理
- **部门主管设置**：部门领导指派与管理
- **部门员工管理**：员工部门分配、批量部门调整

### 2.4 员工管理模块 ✅

- **员工基本信息管理**：
  - 员工创建（支持身份证号自动推断性别）
  - 员工信息更新（姓名、身份证、联系方式、照片等）
  - 员工查询与分页（支持多条件筛选）
- **员工入职/离职流程**：
  - 员工入职处理
  - 员工解雇流程（包含事务回滚机制）
  - 离职时自动清除部门主管设置
- **批量操作**：
  - 批量移出部门
  - 批量添加到部门
- **数据脱敏处理**：
  - 电话、邮箱、身份证号脱敏
  - 根据用户角色和关系动态脱敏

### 2.5 员工档案管理模块 ✅

- **档案创建与维护**：
  - 入职日期、离职日期管理
  - 绩效摘要记录
  - 出勤率统计
  - 重大违纪记录
  - 离职原因、年薪等信息
- **档案查询**：
  - 按员工查询所有档案
  - 按公司查询档案
  - 分页查询支持
- **档案权限控制**：不同角色查看权限不同

### 2.6 奖惩记录模块 ✅

- **奖励/惩罚记录**：记录员工奖惩信息
- **金额与日期管理**：奖惩金额、发生日期记录
- **操作审计**：记录操作人信息

---

## 三、技术亮点与技术难点

### 3.1 腾讯云 COS 对象存储集成

#### 技术亮点

系统集成了腾讯云 COS（对象存储服务），用于存储员工照片等文件，实现了文件的高可用、高并发访问。

#### 实现细节

**1. COS 配置类（CosClientConfig.java）**

```java
@Configuration
@ConfigurationProperties(prefix = "cos.client")
@Data
public class CosClientConfig {
    private String host;        // 域名
    private String secretId;   // 密钥ID
    private String secretKey;  // 密钥
    private String region;      // 区域
    private String bucket;      // 桶名

    @Bean
    public COSClient cosClient() {
        // 初始化用户身份信息
        COSCredentials cred = new BasicCOSCredentials(secretId, secretKey);
        // 设置bucket的区域
        ClientConfig clientConfig = new ClientConfig(new Region(region));
        // 生成cos客户端
        return new COSClient(cred, clientConfig);
    }
}
```

**2. COS 管理器（CosManager.java）**

```java
@Component
@Slf4j
public class CosManager {
    @Resource
    private CosClientConfig cosClientConfig;
    @Resource
    private COSClient cosClient;

    /**
     * 上传文件到 COS 并返回访问 URL
     */
    public String uploadFile(String key, File file) {
        PutObjectResult result = putObject(key, file);
        if (result != null) {
            // 构建访问URL，确保 host 与 key 之间有且仅有一个 "/"
            String host = cosClientConfig.getHost();
            if (host.endsWith("/")) {
                host = host.substring(0, host.length() - 1);
            }
            if (key.startsWith("/")) {
                key = key.substring(1);
            }
            String url = host + "/" + key;
            log.info("文件上传COS成功: {} -> {}", file.getName(), url);
            return url;
        }
        return null;
    }
}
```

**3. 文件上传使用示例（EmployeeController.java）**

```java
@PostMapping("/update/me")
public BaseResponse<Boolean> updateMyProfile(
        @RequestPart(required = false) MultipartFile photo,
        HttpServletRequest request) {
    // ... 其他代码 ...

    if (photo != null && !photo.isEmpty()) {
        try {
            // 生成唯一文件键：employee/{userId}/{timestamp}_{filename}
            String key = String.format("employee/%s/%s_%s",
                loginUser.getId(),
                Instant.now().toEpochMilli(),
                photo.getOriginalFilename());

            // 创建临时文件
            File tmp = File.createTempFile("upload_",
                photo.getOriginalFilename());
            photo.transferTo(tmp);

            // 上传到COS
            String url = cosManager.uploadFile(key, tmp);

            // 删除临时文件
            try {
                Files.deleteIfExists(tmp.toPath());
            } catch (IOException ignored) {
            }

            // 设置员工照片URL
            employee.setPhotoUrl(url);
        } catch (IOException e) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR,
                "文件处理失败");
        }
    }

    // ... 其他代码 ...
}
```

#### 技术难点与解决方案

- **难点 1**：URL 拼接问题

  - **解决方案**：统一处理 host 和 key 的路径分隔符，确保 URL 格式正确

- **难点 2**：临时文件管理

  - **解决方案**：使用 `File.createTempFile()` 创建临时文件，上传后立即删除，避免磁盘空间浪费

- **难点 3**：文件唯一性
  - **解决方案**：使用 `userId + timestamp + filename` 组合生成唯一键，避免文件覆盖

---

### 3.2 事务管理与数据一致性保障

#### 技术亮点

系统在关键业务操作中使用了 Spring 事务管理，确保数据一致性。特别是在员工创建和解雇流程中，实现了完整的事务回滚机制。

#### 实现细节

**1. 员工创建时的数据一致性保障（EmployeeServiceImpl.java）**

```java
@Override
public long employeeCreate(Long companyId, String name, String gender,
        String phone, String email, String idCardNumber,
        Long departmentId, boolean isAdmin) {
    // ... 参数校验 ...

    // 先创建用户账户
    long userId = userService.userRegister(idCardNumber,
        UserRoleEnum.EMPLOYEE.getValue(), name,
        DEFAULT_PASSWORD, DEFAULT_PASSWORD);
    newEmployee.setUserId(userId);

    // 尝试保存员工信息，如果失败则物理删除已创建的 user 记录
    try {
        boolean saveResult = this.save(newEmployee);
        if (!saveResult) {
            // 保存失败，物理删除已创建的 user 记录
            userMapper.deleteByIdPhysically(userId);
            throw new BusinessException(ErrorCode.OPERATION_ERROR,
                "添加失败，请重试");
        }
    } catch (Exception e) {
        // 捕获任何异常，物理删除已创建的 user 记录
        try {
            userMapper.deleteByIdPhysically(userId);
            log.info("已物理删除用户记录，userId: {}", userId);
        } catch (Exception deleteException) {
            log.error("删除用户记录失败，userId: {}", userId, deleteException);
        }
        // 如果是业务异常，直接抛出；否则包装为业务异常
        if (e instanceof BusinessException) {
            throw e;
        } else {
            log.error("添加员工失败，已回滚用户记录，userId: {}", userId, e);
            throw new BusinessException(ErrorCode.OPERATION_ERROR,
                "添加失败，请重试");
        }
    }

    return newEmployee.getId();
}
```

**2. 员工解雇的事务处理（EmployeeServiceImpl.java）**

```java
@Override
@Transactional(rollbackFor = Exception.class)
public Boolean confirmFireEmployee(Long employeeId, User loginUser) {
    // 权限校验
    // ...

    // 检查该员工是否是某个部门的主管，如果是，需要清除部门的主管设置
    int clearedDepartments = departmentMapper.clearLeaderIdByEmployeeId(employeeId);
    if (clearedDepartments > 0) {
        log.info("解雇员工 {} 时，清除了 {} 个部门的主管设置",
            employeeId, clearedDepartments);
    }

    // 执行解雇操作：将companyId和departmentId置为null，status置为false
    // 使用原生SQL确保null值能够被正确更新
    int affectedRows = this.mapper.fireEmployee(employeeId);
    ThrowUtils.throwIf(affectedRows <= 0, ErrorCode.OPERATION_ERROR,
        "解雇操作失败");

    return true;
}
```

**3. 批量操作的事务处理（EmployeeServiceImpl.java）**

```java
@Override
@Transactional(rollbackFor = Exception.class)
public int batchAddToDepartment(List<Long> employeeIds, Long departmentId,
        User loginUser) {
    // 权限校验
    // ...

    // 验证部门存在
    Department department = departmentService.getById(departmentId);
    ThrowUtils.throwIf(department == null, ErrorCode.NOT_FOUND_ERROR,
        "部门不存在");

    // 查询出所有需要更新的员工实体（只查询一次，避免重复查询）
    List<Employee> employeesToUpdate = new ArrayList<>();
    for (Long employeeId : employeeIds) {
        Employee employee = this.getById(employeeId);
        ThrowUtils.throwIf(employee == null, ErrorCode.NOT_FOUND_ERROR,
            "员工不存在，ID: " + employeeId);
        employeesToUpdate.add(employee);
    }

    // 权限校验：非系统管理员只能添加本公司员工到本公司部门
    // ...

    // 使用 MyBatis-Flex 的批量更新方法
    boolean updateResult = UpdateChain.of(Employee.class)
            .set(Employee::getDepartmentId, departmentId)
            .where(Employee::getId).in(employeeIdList)
            .update();

    ThrowUtils.throwIf(!updateResult, ErrorCode.OPERATION_ERROR,
        "批量添加到部门失败");

    return employeesToUpdate.size();
}
```

#### 技术难点与解决方案

- **难点 1**：跨表数据一致性

  - **解决方案**：使用 `@Transactional` 注解确保多表操作的事务性，任何异常都会回滚

- **难点 2**：NULL 值更新问题

  - **解决方案**：使用原生 SQL 方法确保 NULL 值能够被正确设置（MyBatis-Flex 的 UpdateChain 可能无法正确处理 NULL）

- **难点 3**：批量操作性能
  - **解决方案**：先批量查询所有需要更新的实体，然后使用批量更新方法，避免 N+1 查询问题

---

### 3.3 基于 AOP 的权限控制

#### 技术亮点

系统实现了基于 AOP（面向切面编程）的权限拦截器，通过自定义注解 `@AuthCheck` 实现声明式的权限控制，代码简洁且易于维护。

#### 实现细节

**1. 权限检查注解（AuthCheck.java）**

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AuthCheck {
    /**
     * 必须有某个角色
     */
    String mustRole() default "";
}
```

**2. 权限拦截器（AuthInterceptor.java）**

```java
@Aspect
@Component
public class AuthInterceptor {

    @Resource
    private UserService userService;

    /**
     * 执行拦截
     */
    @Around("@annotation(authCheck)")
    public Object doInterceptor(ProceedingJoinPoint joinPoint,
            AuthCheck authCheck) throws Throwable {
        String mustRole = authCheck.mustRole();
        RequestAttributes requestAttributes =
            RequestContextHolder.currentRequestAttributes();
        HttpServletRequest request =
            ((ServletRequestAttributes) requestAttributes).getRequest();

        // 当前登录用户
        User loginUser = userService.getLoginUser(request);
        UserRoleEnum mustRoleEnum = UserRoleEnum.getEnumByValue(mustRole);

        // 不需要权限，放行
        if (mustRoleEnum == null) {
            return joinPoint.proceed();
        }

        // 获取当前用户具有的权限
        UserRoleEnum userRoleEnum =
            UserRoleEnum.getEnumByValue(loginUser.getUserRole());

        // 没有权限，拒绝
        if (userRoleEnum == null) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }

        // 角色等级比较：admin > company_admin > hr > employee
        if (roleRank(userRoleEnum) < roleRank(mustRoleEnum)) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }

        // 通过权限校验，放行
        return joinPoint.proceed();
    }

    /**
     * 简单的角色等级映射，数值越大权限越高
     */
    private int roleRank(UserRoleEnum role) {
        if (role == null) {
            return 0;
        }
        switch (role) {
            case ADMIN: return 4;
            case COMPANY_ADMIN: return 3;
            case HR: return 2;
            case EMPLOYEE: return 1;
            default: return 0;
        }
    }
}
```

**3. 使用示例（EmployeeController.java）**

```java
@RestController
@RequestMapping("/employee")
public class EmployeeController {

    /**
     * 员工创建 - 需要HR及以上权限
     */
    @AuthCheck(mustRole = UserConstant.HR_ROLE)
    @PostMapping("/create")
    public BaseResponse<Long> employeeCreate(
            @RequestBody EmployeeCreateRequest employeeCreateRequest,
            HttpServletRequest request) {
        // ... 业务逻辑 ...
    }

    /**
     * 分页获取员工列表 - 需要HR及以上权限
     */
    @AuthCheck(mustRole = UserConstant.HR_ROLE)
    @PostMapping("/list/page/vo")
    public BaseResponse<Page<EmployeeVO>> listEmployeeVOByPage(
            @RequestBody EmployeeQueryRequest employeeQueryRequest,
            HttpServletRequest request) {
        // ... 业务逻辑 ...
    }
}
```

#### 技术难点与解决方案

- **难点 1**：权限粒度控制

  - **解决方案**：实现角色等级系统（admin > company_admin > hr > employee），高级角色自动拥有低级角色权限

- **难点 2**：权限与业务逻辑解耦

  - **解决方案**：使用 AOP 切面编程，权限检查逻辑与业务逻辑完全分离，代码更清晰

- **难点 3**：动态权限判断
  - **解决方案**：在业务层根据用户角色动态构建查询条件，例如 HR 只能查看本公司员工

---

### 3.4 数据脱敏处理

#### 技术亮点

系统实现了基于角色和关系的动态数据脱敏机制，保护员工隐私信息，同时保证业务功能的正常使用。

#### 实现细节

**数据脱敏实现（EmployeeController.java）**

```java
/**
 * 获取部门同事列表（脱敏版本，仅员工角色可访问）
 * 脱敏规则：电话、邮箱、身份证号脱敏
 * 当登录的员工为部门主管时，同事列表信息不进行脱敏处理
 */
@GetMapping("/colleagues/department")
public BaseResponse<List<EmployeeVO>> getDepartmentColleagues(
        HttpServletRequest request) {
    User loginUser = userService.getLoginUser(request);

    // 通过 userId 查找当前员工的 employee 信息
    QueryWrapper qw = QueryWrapper.create()
            .eq("user_id", loginUser.getId());
    Employee currentEmployee = employeeService.getOne(qw);

    // 获取部门信息，确定主管ID
    Department department = departmentService
            .getById(currentEmployee.getDepartmentId());
    Long leaderId = department != null ? department.getLeaderId() : null;

    // 判断当前登录员工是否为部门主管
    boolean isCurrentEmployeeLeader = leaderId != null
            && currentEmployee.getId() != null
            && currentEmployee.getId().equals(leaderId);

    // 查询同部门的所有员工
    QueryWrapper deptQw = QueryWrapper.create()
            .eq("department_id", currentEmployee.getDepartmentId())
            .eq("company_id", currentEmployee.getCompanyId())
            .eq("status", EmployeeStatusEnum.NORMAL.getValue());
    List<Employee> colleagues = employeeService.list(deptQw);

    // 转换为 VO 并脱敏
    List<EmployeeVO> colleagueVOs = employeeService.getEmployeeVOList(colleagues);

    // 脱敏处理：电话、邮箱、身份证号
    // 如果当前登录员工是部门主管，则不对同事信息进行脱敏处理
    if (!isCurrentEmployeeLeader) {
        for (EmployeeVO vo : colleagueVOs) {
            // 电话脱敏：保留前3位和后4位，中间用*代替
            if (vo.getPhone() != null && vo.getPhone().length() > 7) {
                String phone = vo.getPhone();
                vo.setPhone(phone.substring(0, 3) + "****"
                    + phone.substring(phone.length() - 4));
            }

            // 邮箱脱敏：保留@前1位和@后部分
            if (vo.getEmail() != null && vo.getEmail().contains("@")) {
                String email = vo.getEmail();
                int atIndex = email.indexOf("@");
                if (atIndex > 0) {
                    vo.setEmail(email.substring(0, 1) + "***"
                        + email.substring(atIndex));
                }
            }

            // 身份证号脱敏：保留前6位和后4位
            if (vo.getIdCardNumber() != null
                    && vo.getIdCardNumber().length() > 10) {
                String idCard = vo.getIdCardNumber();
                vo.setIdCardNumber(idCard.substring(0, 6) + "********"
                    + idCard.substring(idCard.length() - 4));
            }
        }
    }

    return ResultUtils.success(colleagueVOs);
}
```

#### 技术难点与解决方案

- **难点 1**：脱敏规则设计

  - **解决方案**：根据数据类型设计不同的脱敏规则，保留部分信息用于识别，同时保护隐私

- **难点 2**：动态脱敏判断

  - **解决方案**：根据用户角色和关系（如是否为部门主管）动态决定是否脱敏

- **难点 3**：脱敏性能
  - **解决方案**：在 VO 转换时进行脱敏，避免重复处理，使用字符串操作而非正则表达式提高性能

---

### 3.5 批量操作优化

#### 技术亮点

系统实现了高效的批量操作功能，通过优化查询和更新策略，避免了 N+1 查询问题，提升了系统性能。

#### 实现细节

**批量添加到部门（EmployeeServiceImpl.java）**

```java
@Override
@Transactional(rollbackFor = Exception.class)
public int batchAddToDepartment(List<Long> employeeIds, Long departmentId,
        User loginUser) {
    // ... 参数校验和权限校验 ...

    // 查询出所有需要更新的员工实体（只查询一次，避免重复查询）
    List<Employee> employeesToUpdate = new ArrayList<>();
    for (Long employeeId : employeeIds) {
        Employee employee = this.getById(employeeId);
        ThrowUtils.throwIf(employee == null, ErrorCode.NOT_FOUND_ERROR,
            "员工不存在，ID: " + employeeId);
        employeesToUpdate.add(employee);
    }

    // 权限校验：验证所有员工都属于当前用户公司
    // ...

    // 使用 MyBatis-Flex 的批量更新方法
    List<Long> employeeIdList = employeesToUpdate.stream()
            .map(Employee::getId)
            .collect(Collectors.toList());

    boolean updateResult = UpdateChain.of(Employee.class)
            .set(Employee::getDepartmentId, departmentId)
            .where(Employee::getId).in(employeeIdList)
            .update();

    ThrowUtils.throwIf(!updateResult, ErrorCode.OPERATION_ERROR,
        "批量添加到部门失败");

    log.info("批量添加到部门成功，添加员工数量: {}, 部门ID: {}, 受影响行数: {}",
        employeeIds.size(), departmentId, employeesToUpdate.size());

    return employeesToUpdate.size();
}
```

#### 技术难点与解决方案

- **难点 1**：N+1 查询问题

  - **解决方案**：先批量查询所有需要更新的实体，然后使用批量更新方法

- **难点 2**：批量更新 NULL 值

  - **解决方案**：对于需要设置 NULL 的操作，使用原生 SQL 方法（如 `batchRemoveFromDepartment`）

- **难点 3**：事务性能
  - **解决方案**：在事务中只进行必要的数据库操作，减少事务持有时间

---

### 3.6 权限动态查询构建

#### 技术亮点

系统实现了基于用户角色的动态查询条件构建，确保不同角色只能查看和操作权限范围内的数据。

#### 实现细节

**动态查询条件构建（EmployeeServiceImpl.java）**

```java
@Override
public Page<EmployeeVO> pageEmployeeVOByPage(
        EmployeeQueryRequest employeeQueryRequest, User loginUser) {
    // ... 参数校验 ...

    // 构建查询条件，调用者的权限决定是否限定 company_id
    QueryWrapper qw = QueryWrapper.create();
    // 基本条件来自请求
    qw.eq("id", employeeQueryRequest.getId())
            .like("name", employeeQueryRequest.getName())
            .eq("id_card_number", employeeQueryRequest.getIdCardNumber())
            .like("phone", employeeQueryRequest.getPhone())
            .eq("department_id", employeeQueryRequest.getDepartmentId())
            .eq("status", employeeQueryRequest.getStatus())
            .orderBy(sortField, "ascend".equals(sortOrder));

    // 权限决定 company_id 过滤：管理员可以指定查询某公司，HR 与公司管理员限定为同公司
    UserRoleEnum roleEnum = UserRoleEnum.getEnumByValue(loginUser.getUserRole());
    if (roleEnum == null) {
        throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
    }

    switch (roleEnum) {
        case ADMIN:
            // 管理员可以查看所有或指定公司的员工
            if (requestCompanyId != null) {
                qw.eq("company_id", requestCompanyId);
            }
            break;
        case COMPANY_ADMIN:
        case HR:
            // HR和公司管理员只能查看自己公司的员工
            Long companyId = loginUser.getCompanyId();
            qw.eq("company_id", companyId);
            break;
        default:
            // 其他角色不允许调用此分页接口
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR,
                "无权限查看员工列表");
    }

    // 执行分页查询
    Page<Employee> employeePage = this.page(
        Page.of(pageNum, pageSize), qw);

    // 封装为 VO
    Page<EmployeeVO> employeeVOPage = new Page<>(
        pageNum, pageSize, employeePage.getTotalRow());
    List<EmployeeVO> employeeVOList = getEmployeeVOList(employeePage.getRecords());
    employeeVOPage.setRecords(employeeVOList);

    return employeeVOPage;
}
```

#### 技术难点与解决方案

- **难点 1**：多角色权限控制

  - **解决方案**：使用策略模式，根据用户角色动态构建查询条件

- **难点 2**：权限与查询性能平衡
  - **解决方案**：在数据库层面通过 WHERE 条件过滤，而非在应用层过滤，保证查询性能

---

### 3.7 身份证号自动推断性别

#### 技术亮点

系统实现了根据身份证号自动推断性别的功能，提升了用户体验，减少了手动输入。

#### 实现细节

```java
@Override
public String inferGenderFromIdCard(String idCardNumber) {
    if (idCardNumber == null || idCardNumber.isEmpty()
            || idCardNumber.length() != 18) {
        return null;
    }

    // 18位身份证：第17位（索引16）是性别位
    char genderDigit = idCardNumber.charAt(16);

    // 将字符转换为数字
    int digit;
    try {
        digit = Character.getNumericValue(genderDigit);
    } catch (NumberFormatException e) {
        return null;
    }

    // 奇数为男性，偶数为女性
    return (digit % 2 == 1) ? "男" : "女";
}
```

---

## 四、将来实现的功能

### 4.1 多维度评价系统 ⭐ **第一优先级**

#### 功能概述

实现多维度、多视角的评价体系，支持领导评价、同事评价、HR 评价和自评，并实现季度评价、年度评价、离职评价等多种评价周期。

#### 核心功能

1. **评价类型支持**

   - 领导评价（部门主管对下属）
   - 同事评价（同部门员工互相评价）
   - HR 评价
   - 自评

2. **评价周期体系**

   - 季度评价（每季度初自动生成评价任务）
   - 年度评价
   - 离职评价（离职时自动触发）
   - 临时评价

3. **标签化评价**

   - 预设正面标签和中性标签
   - 只能从预设标签中选择，杜绝恶意评价
   - 标签库管理（系统管理员维护）

4. **维度评分**
   - 固定考核维度（工作业绩、责任心、专业技能、团队协作、创新能力等）
   - 1-5 分评分机制
   - 雷达图可视化展示

#### 技术实现要点

- 数据库设计：添加 `evaluation_type`、`evaluation_period`、`period_year`、`period_quarter` 等字段
- 定时任务：使用 Spring Task 或 Quartz 实现季度评价任务自动生成
- 权限控制：同事评价需要验证同部门关系
- 评价统计：实现多维度评价的加权平均计算

#### 预计时间

**4-5 周**（第一优先级）

---

### 4.2 企业积分系统

#### 功能概述

建立企业信用积分体系，激励企业完善员工档案和提供客观评价。

#### 核心功能

1. **积分获取规则**

   - 为离职员工建立完整档案：+10 分
   - 收到员工好评：+5 分
   - 提供客观评价：根据评价质量加分

2. **积分消耗/权益**

   - 优先检索人才库
   - 获得平台首页推荐位
   - 解锁高级分析功能

3. **积分查询与统计**
   - 企业当前总积分查询
   - 积分变动记录查询
   - 积分排名统计

#### 技术实现要点

- 积分计算服务：封装积分计算规则
- 积分变动记录：记录每次积分变动的原因和关联信息
- 积分统计：实现积分查询和排名功能

#### 预计时间

**1-2 周**

---

### 4.3 档案查阅请求系统

#### 功能概述

实现企业间的档案查阅请求机制，员工可以授权或拒绝查阅请求，保护隐私的同时支持人才流动。

#### 核心功能

1. **查阅请求管理**

   - 企业发起查阅请求
   - 员工授权/拒绝请求
   - 请求状态管理（待处理、已授权、已拒绝、已过期）

2. **权限控制**

   - 档案公开范围设置（完全保密、对认证企业可见、公开）
   - 员工管理查阅请求
   - 查阅记录审计

3. **数据脱敏**
   - 根据权限显示不同信息
   - 外部企业查看时自动脱敏

#### 技术实现要点

- 请求表设计：`profile_access_request` 表
- 审计日志：`profile_access_log` 表记录所有查阅操作
- 通知系统：员工收到查阅请求时发送通知

#### 预计时间

**2 周**

---

### 4.4 通知系统

#### 功能概述

实现系统通知功能，包括评价任务通知、查阅请求通知等。

#### 核心功能

1. **通知类型**

   - 评价任务通知（季度/年度/离职评价提醒）
   - 查阅请求通知
   - 系统通知
   - 投诉处理通知

2. **通知管理**

   - 通知创建与发送
   - 通知状态管理（未读、已读、已处理）
   - 通知查询

3. **定时任务**
   - 季度评价提醒（每季度初）
   - 年度评价提醒（每年初）
   - 离职评价提醒（离职时）

#### 技术实现要点

- 通知表设计：`notification` 表
- 定时任务：使用 Spring Task 实现定时通知
- 前端推送：考虑使用 WebSocket 实现实时通知

#### 预计时间

**1 周**

---

### 4.5 投诉与反馈系统

#### 功能概述

实现员工投诉功能，对恶意评价进行反馈和投诉。

#### 核心功能

1. **投诉管理**

   - 员工对恶意评价的投诉
   - 投诉类型（恶意评价、虚假信息、其他）
   - 证据上传（图片、链接等）

2. **投诉处理**
   - 系统管理员处理投诉
   - 投诉状态管理（待处理、处理中、已处理、已驳回）
   - 处理结果记录

#### 技术实现要点

- 投诉表设计：`complaint` 表
- 证据存储：使用 COS 存储投诉证据
- 投诉流程：实现投诉处理工作流

#### 预计时间

**1 周**

---

### 4.6 人才看板功能

#### 功能概述

为 HR 提供人才看板，展示所管理人才的成长地图和统计数据。

#### 核心功能

1. **数据统计**

   - 人才分布统计（按部门、按岗位）
   - 人才评价趋势分析
   - 人才成长地图

2. **数据可视化**
   - 图表展示（ECharts）
   - 数据报表生成
   - 导出功能（Excel、PDF）

#### 技术实现要点

- 统计服务：实现各种数据统计逻辑
- 数据可视化：使用 ECharts 等图表库
- 报表生成：使用 POI 或 EasyExcel 生成报表

#### 预计时间

**1-2 周**

---

### 4.7 人才库搜索与筛选

#### 功能概述

实现人才库搜索功能，支持多条件筛选和按积分优先级排序。

#### 核心功能

1. **搜索功能**

   - 多条件搜索（姓名、岗位、行业等）
   - 按积分优先级排序
   - 按评价标签筛选

2. **权限控制**
   - 积分高的企业享受优先检索
   - 搜索结果脱敏处理
   - 高级搜索功能（积分高的企业可用）

#### 技术实现要点

- 全文索引：优化搜索性能
- 搜索结果缓存：使用 Redis 缓存热门搜索结果
- 分页优化：大数据量时的分页优化

#### 预计时间

**1 周**

---

### 4.8 Redis 缓存优化（规划中）

#### 功能概述

引入 Redis 缓存，提升系统性能和响应速度。

#### 应用场景

1. **用户信息缓存**

   - 缓存登录用户信息，减少数据库查询
   - 缓存过期时间：30 分钟

2. **查询结果缓存**

   - 缓存热门查询结果（如员工列表、部门列表）
   - 缓存过期时间：5 分钟

3. **统计数据缓存**
   - 缓存人才统计数据
   - 缓存过期时间：1 小时

#### 技术实现要点

- Redis 配置：集成 Spring Data Redis
- 缓存策略：使用 `@Cacheable` 注解实现声明式缓存
- 缓存更新：实现缓存失效和更新机制

#### 预计时间

**1 周**

---

## 五、总结与展望

### 5.1 已完成工作总结

本阶段已完成系统的核心基础功能，包括：

1. **完整的用户权限体系**：基于 AOP 的权限控制，支持多角色管理
2. **企业、部门、员工管理**：完整的企业组织架构管理
3. **员工档案管理**：员工职业档案的创建和维护
4. **数据安全保护**：数据脱敏、权限控制、事务保障
5. **文件存储集成**：腾讯云 COS 对象存储集成

### 5.2 技术亮点总结

1. **COS 对象存储集成**：实现了高效、可靠的文件存储方案
2. **事务管理**：完善的事务回滚机制，保障数据一致性
3. **AOP 权限控制**：声明式权限管理，代码简洁易维护
4. **数据脱敏**：动态脱敏机制，保护隐私信息
5. **批量操作优化**：避免 N+1 查询，提升性能

### 5.3 下一步工作计划

#### 第一优先级（4-5 周）

1. **多维度评价系统**：实现评价系统的核心功能
2. **季度评价体系**：实现季度评价任务自动生成
3. **同事评价功能**：实现同部门员工互相评价

#### 第二优先级（2-3 周）

1. **企业积分系统**：实现积分计算和权益管理
2. **档案查阅请求系统**：实现企业间档案查阅机制

#### 第三优先级（2-3 周）

1. **通知系统**：实现系统通知和定时任务
2. **投诉系统**：实现投诉处理流程
3. **人才看板**：实现数据统计和可视化

#### 第四优先级（持续优化）

1. **Redis 缓存优化**：提升系统性能
2. **人才库搜索**：实现高级搜索功能
3. **系统优化**：性能优化、用户体验优化

### 5.4 预期成果

完成所有功能后，系统将实现：

1. **完整的跨组织人才管理**：从员工入职到离职的全生命周期管理
2. **多维度评价体系**：360 度全方位评价，客观评估员工能力
3. **企业信用体系**：通过积分机制激励企业完善档案
4. **隐私保护机制**：完善的权限控制和数据脱敏
5. **高效的人才匹配**：通过档案查阅和人才搜索，帮助企业快速找到合适人才

---

## 附录

### A. 技术栈

- **后端**：Spring Boot 3.x、MyBatis-Flex、MySQL 8.0
- **前端**：Vue 3、TypeScript、Ant Design Vue
- **存储**：腾讯云 COS
- **工具**：Maven、Git、Lombok

### B. 项目结构

```
cross-org-talent-manager/
├── src/main/java/com/crossorgtalentmanager/
│   ├── controller/      # 控制器层
│   ├── service/         # 服务层
│   ├── mapper/          # 数据访问层
│   ├── model/           # 实体类和DTO
│   ├── aop/             # AOP切面
│   ├── manager/         # 管理器（如COS）
│   ├── config/          # 配置类
│   └── exception/       # 异常处理
└── vue-project/         # 前端项目
```

### C. 关键代码文件

- `AuthInterceptor.java`：权限拦截器
- `CosManager.java`：COS 对象存储管理器
- `EmployeeServiceImpl.java`：员工服务实现（包含事务处理）
- `EmployeeController.java`：员工控制器（包含数据脱敏）

---

**报告日期**：2025 年 1 月

**报告人**：[您的姓名]

**项目状态**：开发中
